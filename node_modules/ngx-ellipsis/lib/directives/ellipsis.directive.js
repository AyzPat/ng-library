"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var elementResizeDetectorMaker = require("element-resize-detector");
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
var EllipsisDirective = (function () {
    /**
     * The directive's constructor
     */
    function EllipsisDirective(elementRef, renderer, ngZone) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Wether the ellipsis should be applied on window resize
         */
        this.applyOnWindowResize = false;
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from innerHTML
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         *  If anything is passed, the ellipsisCharacters will be
         *  wrapped in <a></a> tags and an event handler for the
         *  passed function will be added to the link
         */
        this.moreClickEmitter = new core_1.EventEmitter();
    }
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     */
    EllipsisDirective.prototype.ngAfterViewInit = function () {
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters == '') {
            this.ellipsisCharacters = '...';
        }
        if (this.moreClickEmitter.observers.length > 0) {
            this.ellipsisCharacters = "<a href=\"#\" class=\"ngx-ellipsis-more\">" + this.ellipsisCharacters + "</a>";
        }
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = "[" + this.ellipsisWordBoundaries.replace(/\\n/, "\n").replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + "]";
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (this.ellipsisContent) {
            this.originalText = this.ellipsisContent;
        }
        else if (!this.originalText) {
            this.originalText = this.elem.innerText;
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        var text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        // start listening for resize events:
        this.addResizeListener(true);
    };
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     */
    EllipsisDirective.prototype.ngOnChanges = function () {
        if (!this.elem || !this.ellipsisContent || this.originalText == this.ellipsisContent) {
            return;
        }
        this.originalText = this.ellipsisContent;
        this.applyEllipsis();
    };
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     */
    EllipsisDirective.prototype.ngOnDestroy = function () {
        this.removeAllListeners();
    };
    /**
     * remove all resize listeners
     */
    EllipsisDirective.prototype.removeAllListeners = function () {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListener();
    };
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param  {boolean} triggerNow=false if true, the ellipsis is applied immediately
     */
    EllipsisDirective.prototype.addResizeListener = function (triggerNow) {
        if (triggerNow === void 0) { triggerNow = false; }
        if (typeof (this.resizeDetectionStrategy) == 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'window':
                this.applyOnWindowResize = true;
                if (triggerNow) {
                    this.applyEllipsis();
                }
                break;
            case 'element-resize-detector-object':
                this.addElementResizeListener(false);
                break;
            default:
                if (typeof (console) != 'undefined') {
                    console.warn("No such ellipsis-resize-detection strategy: '" + this.resizeDetectionStrategy + "' - Using 'element-resize-detector' instead");
                }
            case 'element-resize-detector':
            case '':
                this.addElementResizeListener();
                break;
        }
    };
    EllipsisDirective.prototype.onResize = function (event) {
        var _this = this;
        this.ngZone.run(function () {
            if (_this.applyOnWindowResize) {
                _this.applyEllipsis();
            }
        });
    };
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {boolean} scrollStrategy=true Use the default elementResizeDetector's strategy - s. https://github.com/wnr/element-resize-detector
     */
    EllipsisDirective.prototype.addElementResizeListener = function (scrollStrategy) {
        var _this = this;
        if (scrollStrategy === void 0) { scrollStrategy = true; }
        if (!EllipsisDirective.elementResizeDetector) {
            EllipsisDirective.elementResizeDetector = elementResizeDetectorMaker({ strategy: scrollStrategy ? 'scroll' : 'object' });
        }
        var calledAsynchronously = false;
        EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, function () {
            if (!calledAsynchronously) {
                // elementResizeDetector fires the event directly after re-attaching the listener
                // -> discard that first event:
                return;
            }
            _this.applyEllipsis();
        });
        calledAsynchronously = true;
    };
    /**
     * Stop listening for any resize event.
     */
    EllipsisDirective.prototype.removeResizeListener = function () {
        if (this.resizeDetectionStrategy != 'window') {
            if (EllipsisDirective.elementResizeDetector && this.elem) {
                EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
            }
        }
        else {
            this.applyOnWindowResize = false;
        }
    };
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param  {number} max the maximum length the text may have
     * @return string       the truncated string
     */
    EllipsisDirective.prototype.getTruncatedText = function (max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        var truncatedText = this.originalText.substr(0, max);
        if (this.ellipsisWordBoundaries == '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText + this.ellipsisCharacters;
        }
        for (var i = max - 1; i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries); i--)
            ;
        return truncatedText.substr(0, i) + this.ellipsisCharacters;
    };
    /**
     * Set the truncated text to be displayed in the inner div
     * @param  {number} max the maximum length the text may have
     * @param {boolean} addMoreListener=false listen for click on the ellipsisCharacters if the text has been truncated
     */
    EllipsisDirective.prototype.truncateText = function (max, addMoreListener) {
        var _this = this;
        if (addMoreListener === void 0) { addMoreListener = false; }
        var text = this.getTruncatedText(max);
        this.renderer.setProperty(this.innerElem, 'innerHTML', text);
        if (!addMoreListener) {
            return;
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        // If the text has been truncated, add a more click listener:
        if (text != this.originalText) {
            this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', function (e) {
                if (!e.target || e.target.className != 'ngx-ellipsis-more') {
                    return;
                }
                e.preventDefault();
                _this.moreClickEmitter.emit(e);
            });
        }
    };
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     */
    EllipsisDirective.prototype.applyEllipsis = function () {
        var _this = this;
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListener();
        // Find the best length by trial and error:
        var maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, function (curLength) {
            _this.truncateText(curLength);
            return !_this.isOverflowing;
        });
        // Apply the best length:
        this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
        // Re-attach the resize listener:
        this.addResizeListener();
    };
    Object.defineProperty(EllipsisDirective.prototype, "isOverflowing", {
        /**
         * Whether the text is exceeding the element's boundaries or not
         */
        get: function () {
            // Enforce hidden overflow (required to compare client width/height with scroll width/height)
            var currentOverflow = this.elem.style.overflow;
            if (!currentOverflow || currentOverflow === "visible") {
                this.elem.style.overflow = "hidden";
            }
            var isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
            // Reset overflow to the original configuration:
            this.elem.style.overflow = currentOverflow;
            return isOverflowing;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param  {number} max      Highest possible number
     * @param  {number} callback Should return true as long as the passed number is valid
     * @return {number}          Largest possible number
     */
    EllipsisDirective.numericBinarySearch = function (max, callback) {
        var low = 0;
        var high = max;
        var best = -1;
        var mid;
        while (low <= high) {
            mid = ~~((low + high) / 2);
            var result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    };
    return EllipsisDirective;
}());
/**
 * Instance of https://github.com/wnr/element-resize-detector
 */
EllipsisDirective.elementResizeDetector = null;
EllipsisDirective.decorators = [
    { type: core_1.Directive, args: [{
                selector: '[ellipsis]'
            },] },
];
/** @nocollapse */
EllipsisDirective.ctorParameters = function () { return [
    { type: core_1.ElementRef, },
    { type: core_1.Renderer2, },
    { type: core_1.NgZone, },
]; };
EllipsisDirective.propDecorators = {
    'ellipsisCharacters': [{ type: core_1.Input, args: ['ellipsis',] },],
    'ellipsisContent': [{ type: core_1.Input, args: ['ellipsis-content',] },],
    'ellipsisWordBoundaries': [{ type: core_1.Input, args: ['ellipsis-word-boundaries',] },],
    'resizeDetectionStrategy': [{ type: core_1.Input, args: ['ellipsis-resize-detection',] },],
    'moreClickEmitter': [{ type: core_1.Output, args: ['ellipsis-click-more',] },],
    'onResize': [{ type: core_1.HostListener, args: ['window:resize', ['$event'],] },],
};
exports.EllipsisDirective = EllipsisDirective;
//# sourceMappingURL=ellipsis.directive.js.map